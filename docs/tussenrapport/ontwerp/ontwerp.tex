\documentclass{scrreprt} % scrartcl of scrreprt
\input{../../library/preamble.tex}
\input{../../library/style.tex}
\addbibresource{../../library/bibliography.bib}

\date{22 november 2013}

\begin{document}
\chapter{Ontwerp}
Ons GPU is ingedeeld volgens het volgende blokschema.
\begin{figure}[H]
\centering
        \includegraphics[width=\linewidth]{resources/systeemdrawing-rc.pdf}
        \caption{Blokschema GPU}
        \label{fig:Blokschema GPU}
\end{figure}

\section{Parameters}
In Tabel \ref{tab:spec-params} staat een overzicht van de gebruikte parameters en generics.

\begin{table}[H]
\centering
\caption{De gebruikte parameters en generics}
\label{tab:spec-params}
\begin{tabular}{l l l l l}
	\hline\hline
 	 & Naam & Type & Waarde & Omschrijving\\
 	\hline
	%GLOBAL
	pkg & InstrSize & integer & 4 & De grootte van een instuctie\\ 
	pkg & MaxNumPackets & integer & 3 & Maximaal aantal pakketjes in één instuctie\\ 
	pkg & NumDrawModules & integer & 6 & Aantal Draw modules\\ 
	pkg & SizeX & integer & 8 & Het aantal bits voor de X coordinaat\\
	pkg & SizeY & integer & 7 & Het aantal bits voor de Y coordinaat\\
	pkg & NumStateReg & integer & 1 & Aantal globale state registers\\
	pkg & SizeRAMData & integer & 4 & Aantal bits per woord in het RAM\\
	pkg & SizeRAMAddr & integer & 16 & Aantal adresbits voor het RAM\\
	pkg & SizeColor & integer & 4 & Aantal bits kleur\\
	pkg & SizeSPIData & integer & 8 & Aantal bits van de SPI pakketjes\\
	%VGA
	vga & h\_pulse & integer & 24 & Aantal klokpulsen voor de horizontale syncpuls\\ 
	vga & h\_bp & integer & 12 & Aantal klokpulsen voor de horizontale “backporch” \\ 
	vga & h\_pixels & integer & 160 & Aantal klokpulsen voor de horizontale pixels \\ 
	vga & h\_fp & integer & 4 & Aantal klokpulsen voor de horizontale “fontporch” \\ 
	vga & h\_pol & std\_logic & ‘0’ & De polariteit van de horizontale syncpuls\\ 
	vga & v\_pulse & integer & 2 & Aantal rijen voor de verticale syncpuls\\ 
	vga & v\_bp & integer & 33 & Aantal rijen voor de verticale “backporch” \\ 
	vga & v\_pixels & integer & 480 & Aantal rijen voor de verticale pixels\\ 
	vga & v\_fp & integer & 10 & Aantal rijen voor de verticale “fontporch” \\ 
	vga & v\_pol & std\_logic & ‘0’ & De polariteit van de verticale syncpuls\\ 
	%SPI
	spi & c & integer & 4 & Het aantal bits van de counter in de SPI module\\
  	\hline
\end{tabular}
\end{table}

\section{SPI Controller}
Voor de communicatie tussen de AVR en onze GPU hebben we een SPI decoder nodig.
De ingang SS staat voor slave select, deze wordt normaal gebruikt voor het geval dat je meerdere slave chips hebt, aangezien dit bij ons niet het geval is zal dit signaal altijd hoog zijn.
De in- en uitgangen zijn gespecificeerd in Tabel \ref{tab:spec-spi}.

\begin{table}[H]
\centering
\caption{Specificaties van de SPI Controller (spi)}
\label{tab:spec-spi}
\begin{tabular}{c c c}
	\hline\hline
 	Naam & Modus & Type\\
 	\hline
	clk & in & std\_logic \\
	reset & in & std\_logic \\
	SPI\_CLK & in & std\_logic \\
	SPI\_SS & in & std\_logic \\
	SPI\_MOSI & in & std\_logic \\
	SPI\_MISO & out & std\_logic \\
	SPI\_DONE & out & std\_logic \\
	DataToTx & in & std\_logic\_vector(SizeSPIData-1 downto 0) \\
	DataToTxLoad & in & std\_logic \\
	DataRxd & out & std\_logic\_vector(SizeSPIData-1 downto 0) \\
  	\hline
\end{tabular}
\end{table}

\section{Instruction Decoder}
De instructiedecoder is er om de door de AVR geleverde data te vertalen naar data (een instructie), waar de draw-module mee over weg kan.
De decoder leest van SPI-interface een byte (SPIDataRxd), wanneer de SPI-interface aangeeft dat deze klaar staat (SPIDataAvailable).
Deze byte wordt vervolgens afhankelijk van een interne counter vertaald naar een instructie, kleur of coördinaat.
Wanneer de decoder met zijn ingebouwde counter bepaalt dat de instructiedata (één of meer bytes) geheel ontvangen is, wordt de bijbehorende actie ondernomen.
Dit houdt in dat de gewenste draw-module wordt geactiveerd (met het signaal en), of het screen buffer wordt omgewisseld (reg\_id, reg\_value, reg\_set).
Het actieve screen buffer wordt bijgehouden in een globaal register.
Dit alles gebeurt uiteraard geheel synchroon en uitgangsdata blijft beschikbaar tot de volgende instructie door middel van flip-flops.
De in- en uitgangen zijn gespecificeerd in Tabel \ref{tab:spec-decoder}.

\begin{table}[H]
\centering
\caption{Specificaties van de Insctructie Decoder (decoder)}
\label{tab:spec-decoder}
\begin{tabular}{c c c}
	\hline\hline
 	Naam & Modus & Type\\
 	\hline
	clk & in & std\_logic \\
	reset & in & std\_logic \\	
	SPIDataRxd & out & std\_logic\_vector(SizeSPIData-1 downto 0) \\
	SPIDataAvailable & in & std\_logic \\
	x0 &  buffer & std\_logic\_vector(SizeX-1 downto 0) \\
	x1 &  buffer & std\_logic\_vector(SizeX-1 downto 0) \\
	y0 &  buffer & std\_logic\_vector(SizeY-1 downto 0) \\
	y1 &  buffer & std\_logic\_vector(SizeY-1 downto 0) \\
	color &  buffer & std\_logic\_vector(SizeColor-1 downto 0) \\
	en & buffer & std\_logic\_vector(NumDrawModules-1 downto 0)\\
	reg\_id & out & std\_logic \\
	reg\_value & out & std\_logic \\
	reg\_set & out & std\_logic \\
  	\hline
\end{tabular}
\end{table}

\section{Draw Module}
In dit blok worden de instructie omgezet naar pixels, vierkanten, lijnen, cirkels en eventueel meer. Dit blok krijgt de informatie binnen van de instructiedecoder, deze geeft aan welke module er gebruikt moet worden met de bijbehorende coördinaten en kleur.
De keuze voor welke module er gebruikt moet worden gebeurd doormiddel van het signaal enabled. Verder neemt het draw blok het signaal ASB mee, zodat er in de juiste screenbuffer geschreven wordt.
Tevens krijgt het draw-blok het signaal RAMclaimed binnen van de VGA controller, dit houdt in dat als de VGA controller aan het lezen is in het RAM dat het draw-blok er niet in kan schrijven.
Als laatste ingang krijgt het draw-blok een signaal write binnen van de RAM controller dat zegt wanneer er geschreven mag worden.
Als uitgangen heeft het draw-blok het signaal done als de module klaar is met het tekenen van een de instructie zodat er een volgende instructie kan doorgegeven worden. Verder heeft het de uitgangen naar de RAM controller, hierin worden de kleur 
De in- en uitgangen zijn gespecificeerd in Tabel \ref{tab:spec-draw}.

\begin{table}[H]
\centering
\caption{Specificaties van de Draw Module (draw)}
\label{tab:spec-draw}
\begin{tabular}{c c c}
	\hline\hline
 	Naam & Modus & Type\\
 	\hline	
	write\_enable & out & std\_logic\\
	vga\_claim & in & std\_logic\\
	decoder\_claim & in & std\_logic\\
	is\_init & in & std\_logic\\
	decoder\_write & in & std\_logic\\
	draw\_write & in & std\_logic\\
	draw\_read & in & std\_logic\\
	vga\_read & in & std\_logic\\
	draw\_can\_access & out & std\_logic\\
	decoder\_can\_access & out & std\_logic\\
	vga\_can\_access & out & std\_logic\\
  	\hline
\end{tabular}
\end{table}

\subsection { pixel}
Hierin worden aparte pixels getekend, hiervoor zijn de x,y coördinaten en de kleur nodig.

\subsection { square}
In deze module wordt een vierkant getekend met de x,y coördinaten van de eerste pixel links boven en de laatste pixel rechtsonder van het vierkant en natuurlijk de kleur die het vierkant moet hebben.

\subsection { lijn}
Hier wordt het algoritme van Bresenham gebruikt hiervoor hebben we de x,y coördinaten nodig van het begin en het eindpunt van de lijn.

\subsection { cirkel}
In deze laatste module gebruiken we het midpoint circle algoritme met x1 als de radius.

\section{RAM Controller}
Omdat we een externe RAM gebruiken voor onze screenbuffers is het nodig om hiervoor communicatie op te stellen, zodat er in het juiste gedeelte van de RAM geschreven en gelezen wordt en dat dit niet tegelijkertijd gebeurd, omdat het RAM dat niet aankan. We hebben voor een externe RAM gekozen omdat er geen RAM geheugen groot genoeg gemaakt kon worden met de benodigde transistoren om bijvoorbeeld de screenbuffers te renderen. De RAM controller stuurt naar het draw-blok een signaal write als het mag gaan schrijven in het RAM geheugen, de RAM controller krijgt dan de kleur en het adress binnen van het draw-blok. Als de VGA controller mag gaan lezen krijgt het een signaal read binnen van de RAM controller dan zal er weer data naar de VGA controller verstuurd worden, kleur en adres.

\begin{table}[H]
\centering
\caption{Specificaties van de RAM Controller (ramcontroller)}
\label{tab:spec-ramcontroller}
\begin{tabular}{c c c}
	\hline\hline
 	Naam & Modus & Type\\
 	\hline	
	write\_enable & out & std\_logic\\
	vga\_claim & in & std\_logic\\
	decoder\_claim & in & std\_logic\\
	is\_init & in & std\_logic\\
	decoder\_write & in & std\_logic\\
	draw\_write & in & std\_logic\\
	draw\_read & in & std\_logic\\
	vga\_read & in & std\_logic\\
	draw\_can\_access & out & std\_logic\\
	decoder\_can\_access & out & std\_logic\\
	vga\_can\_access & out & std\_logic\\
  	\hline
\end{tabular}
\end{table}

\section{VGA Controller}
De VGA controller is er om de screenbuffer uit te lezen en de data die daarin staat naar het beeldscherm te sturen. Het leest van de screenbuffer op het moment dat er niet in geschreven wordt, de inverse van ASB dus. Als de controller het RAM geheugen claimt met het signaal RAMclaimed mag er niet worden geschreven in het RAM. De VGA controller leest dan de signalen h- en v-sync (de positie van de pixel) en de waardes van RGBI ( rood , groen, blauw en de intensiteit) af. Het uitlezen van de screenbuffer kost 55 ns en is dus snel genoeg aangezien een klokpuls 160 ns is. In de overige tijd kan er dus geschreven worden in het RAM.

\begin{table}[H]
\centering
\caption{Specificaties van de VGA Controller (vgacontroller)}
\label{tab:spec-vgacontroller}
\begin{tabular}{c c c}
	\hline\hline
 	Naam & Modus & Type\\
 	\hline	
	clk & in & std\_logic \\ 
	reset\_n & in & std\_logic \\ 
	vgahsync & out & std\_logic \\ 
	vgavsync & out & std\_logic \\ 
	vgacolor & out & std\_logic\_vector(SizeColor-1 downto 0) \\
	ramclaim & out & std\_logic \\ 
	ramaddr & out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
	ramdata & in & std\_logic\_vector(SizeRAMData-1 downto 0) \\ 
	ramread & out & std\_logic \\
	asb & in & std\_logic \\
  	\hline
\end{tabular}
\end{table}

\end{document}