\documentclass{scrartcl} % scrartcl of scrreprt
\input{../../library/preamble.tex}
\input{../../library/style.tex}
\addbibresource{../../library/bibliography.bib}

\author{}
\title{EPO3: Eindrapport - Ontwerp}

\begin{document}
\chapter{Systeem Overzicht}
\label{ch:ontwerp}

Het uiteindelijke ontwerp is te zien in figuur ~\ref{fig:Blokschema GPU}. In het schema staat hoe de GPU is verdeeld en staat wat voor interacties er onderling plaatsvindt tussen de modules.
Elke module, behalve de State Registers, is een component van de GPU met zijn eigen in VHDL beschreven gedrag en met zijn eigen functie. De module State Registers is eigenlijk gewoon één signaal, maar het is zo weergegeven, omdat het visueel duidelijker weergeeft wat het ASB signaal doet, namelijk het geeft weer op welke screenbuffer er geschreven moet worden en van welke gelezen moet worden en dat is makkelijker te zien als blokje dan als een lijn. De screenbuffers zelf zitten in het externe SRAM. 
\\ De GPU is verdeeld in 5 modules: de SPI Decoder, de Instructie Decoder, de Draw Logic, de RAM Controller en de VGA Controller. Daarbij is de Draw Logic module nog verdeeld in modules om de verschillende functies voor verschillende vormen te representeren. Er zijn vier modules: Draw Pixel, Draw Rectangle, Draw Line en Draw Sprite.
\\Wat er precies gebeurt in de modules zal uitgelegd worden bij de hoofdstukken met de naam van de desbetreffende module, maar in dit hoofdstuk zal de nadruk liggen op de interacties tussen de modules.

\section{Externe AVR --> SPI Decoder}
De SPI decoder krijgt door middel van de SPI verbinding met de SPI module op de AVR de benodigde data om iets te tekenen binnen. Deze SPI verbinding bestaat uit een CLK en een MISO signaal, er is hier geen MOSI signaal gebruikt, omdat er geen data terug gestuurd hoeft te worden. Het CLK signaal is de klok waarop het verzenden van data tussen de SPI modules is gesynchroniseerd. Het MISO signaal is voor het serieel verzenden van data van de CPU naar de GPU. Er is ook een SS signaal voor het kiezen van de juiste slave waar de data heen gestuurd moet worden, maar er is hier maar één slave dus is SS altijd hoog en hoeft niet door de GPU gestuurd te worden.

\section{SPI decoder <--> Instructie Decoder}
De SPI verstuurd de ontvangen data naar de Instructie Decoder in 8-bit pakketjes met een signaal dat aangeeft dat er nieuwe data beschikbaar is. De SPI krijgt dan een reset signaal van de Instructie Decoder als het pakketje volledig binnen is gekomen.

\section{Instructie Decoder --> Externe AVR}
De Instructie Decoder stuurt direct een interrupt signaal naar de AVR om aan te geven wanneer een pakketje is vertaald naar instructies, dus nadat een instructie klaar is.

\section{Instructie Decoder <--> Draw Logic}
De Instructie Decoder stuurt dan de data vertaald in instructies naar de Draw Logic in de vorm van X, W, Y, H, Color, ID en Enable. Draw Logic geeft zijn status weer aan de Instructie Decoder middels een draw\_ready signaal dat aangeeft of Draw Logic zijn volgende instructie kan verwerken of nog steeds bezig is met een instructie.

\section {Instructie Decoder <--> RAM Controller}
Voor het inladen van sprites in het externe SRAM stuurt de Instructie Decoder direct data naar de RAM Controller en daarbij stuurt de Instructie Decoder een decoder\_claim signaal om te voorkomen dat andere modules tegelijkertijd dingen in of uit het externe SRAM gaan lezen of schrijven. De RAM Controller stuurt het signaal decoder\_can\_access naar de Instructie Decoder dat verteld of RAM Controller bezig is met instructies van een andere module.

\section {Instructie Decoder --> Draw Logic \& VGA Controller}
De Instructie Decoder stuurt het ASB signaal naar de Draw Logic en de VGA Controller om ervoor te zorgen dat de juiste instructie in het juiste screenbuffer wordt gelezen of geschreven. De Instructie Decoder bepaald hiermee in welk screenbuffer wordt geschreven en uit welke screenbuffer wordt gelezen.

\section {Draw Logic <--> Modules}
Draw Logic verstuurt de verkregen instructies van de Instructie Decoder naar de juiste module. De desbetreffende module stuurt dan de naar pixels verwerkte instructie terug naar de Draw Logic met een signaal dat het klaar is met het verwerken van de instructie en dus klaar is voor de volgende instructie.

\section {Draw Logic <--> RAM Controller}
Draw Logic stuurt de naar pixel verwerkte instructies van de modules in de vorm van Data, de kleur, en Addr, het pixel coördinaat, naar de RAM Controller met het draw\_write signaal en draw\_read. Het draw\_write signaal geeft aan dat de Draw Logic in de screenbuffer wilt schrijven. En het draw\_read signaal is voor het uitlezen van de desbetreffende sprites die in het externe SRAM geschreven staan.
RAM Controller stuurt ook een draw\_can\_access signaal naar de Draw Logic, zodat het weet of de RAM Controller bezig is met instructies van andere modules of de RAM Controller vrij is.

\section{RAM Controller <--> Externe SRAM}
De RAM Controller stuurt de Data en Addr signalen van de Draw Logic, de Sprite data van de Instructie Decoder en de Addr signalen van de VGA Controller met een write\_enable signaal naar de externe SRAM. De Data en Addr signalen worden ingeschreven in de screenbuffer in het externe SRAM. De Sprite Data moet in het externe RAM geschreven worden.
Ook moet de RAM Controller de opgeslagen data uit het externe SRAM uit kunnen lezen.

\section{VGA Controller <--> RAM Controller}
De VGA Controller stuurt de signalen Addr, vga\_read en vga\_claim naar de RAM Controller. Het Addr signaal past de pixel coördinaten aan, zodat het past in de gekozen pixel beeld resolutie voor de monitor. Het vga\_read signaal geeft aan dat één van de screenbuffers uitgelezen en naar de VGA DAC gestuurd moet worden, om een schermafbeelding op de monitor te maken. Het vga\_claim signaal zorgt ervoor dat andere modules geen toegang krijgen tot de RAM Controller, als voorbereiding voor het uitlezen van een screenbuffer.
De RAM Controller stuurt een vga\_can\_access signaal naar de VGA Controller, zodat het weet wanneer de RAM Controller vrij is.

\section{VGA Controller --> Externe VGA DAC}
De VGA Controller stuurt vgahsync, vgavsync en vga\_claim naar de Externe VGA DAC. De vgahsync en vgavsync zijn signalen die zorgen voor de juiste VGA timing die nodig is om de monitor juist aan te sturen voor een vloeiend beeld. De vga\_claim komt als het signaal vga\_enabled aan bij de VGA DAC, zodat het weet dat de er een screenbuffer uitgelezen gaat worden.


%%%%%%%------------ONDERSTAANDE MOET NAAR BIJLAGE
\section{Parameters} 
In Tabel \ref{tab:spec-params} staat een overzicht van de gebruikte parameters en generics uit onze GPU.

\begin{table}[H]
\centering
\caption{De gebruikte parameters en generics}
\label{tab:spec-params}
\begin{tabular}{l l l l l}
	\hline\hline
 	 & Naam & Type & Waarde & Omschrijving\\
 	\hline
	%GLOBAL
	pkg & InstrSize & integer & 3 & De grootte van een instructie\\ 
	pkg & MaxNumPackets & integer & 3 & Maximaal aantal pakketjes in één instructie\\ 
	pkg & SizeSpriteID & integer & 10 & Het aantal bits voor het SpriteID \\
	pkg & SizeSpriteCounter & integer & 6 & Het aantal bits voor de sprite counter\\
	pkg & TimoutCount & integer & $2**7-1$ & Het aantal ticks per timout\\
	pkg & SizeTimeoutCounter & integer & 8 & Het aantal bits voor de timout counter\\
	pkg & NumDrawModules & integer & 6 & Aantal Draw modules\\ 
	pkg & SizeX & integer & 8 & Het aantal bits voor de X coordinaat\\
	pkg & SizeY & integer & 7 & Het aantal bits voor de Y coordinaat\\
	pkg & NumStateReg & integer & 1 & Aantal globale state registers\\
	pkg & SizeRAMData & integer & 6 & Aantal bits per woord in het RAM\\
	pkg & SizeRAMAddr & integer & 16 & Aantal adresbits voor het RAM\\
	pkg & SizeColor & integer & 6 & Aantal bits kleur\\
	pkg & SizeSPIData & integer & 8 & Aantal bits van de SPI pakketjes\\
	pkg & ResolutionX & integer & 160 & Horizontale resolutie \\
	pkg & ResolutionY & integer & 120 & Verticale resolutie \\
	%VGA
	vga & h\_pulse & integer & 24 & Aantal klokpulsen voor de horizontale syncpuls\\ 
	vga & h\_bp & integer & 12 & Aantal klokpulsen voor de horizontale “backporch” \\ 
	vga & h\_pixels & integer & 160 & Aantal klokpulsen voor de horizontale pixels \\ 
	vga & h\_fp & integer & 4 & Aantal klokpulsen voor de horizontale “fontporch” \\ 
	vga & h\_pol & std\_logic & ‘0’ & De polariteit van de horizontale syncpuls\\ 
	vga & v\_pulse & integer & 2 & Aantal rijen voor de verticale syncpuls\\ 
	vga & v\_bp & integer & 33 & Aantal rijen voor de verticale “backporch” \\ 
	vga & v\_pixels & integer & 480 & Aantal rijen voor de verticale pixels\\ 
	vga & v\_fp & integer & 10 & Aantal rijen voor de verticale “fontporch” \\ 
	vga & v\_pol & std\_logic & ‘0’ & De polariteit van de verticale syncpuls\\ 
	%SPI
	spi & c & integer & 4 & Het aantal bits van de counter in de SPI module\\
  	\hline
\end{tabular}
\end{table}
%Aanpassen deze figuur
\begin{figure}[H]
\centering
	\includegraphics[scale=0.9, angle=90]{resource/systeemdrawing-detail.png}
	\caption{Ontwerp GPU}
	\label{fig:Blokschema GPU}
\end{figure}


% \section{SPI Controller}
% Voor de communicatie tussen de AVR en onze GPU hebben we een SPI decoder nodig.
% De ingang SS staat voor slave select, deze wordt normaal gebruikt voor het geval dat je meerdere slave chips hebt, aangezien dit bij ons niet het geval is zal dit signaal altijd hoog zijn.
% De in- en uitgangen zijn gespecificeerd in Tabel \ref{tab:spec-spi}.

% \begin{table}[H]
% \centering
% \caption{Specificaties van de SPI Controller (spi)}
% \label{tab:spec-spi}
% \begin{tabular}{c c c}
% 	\hline\hline
%  	Naam & Modus & Type\\
%  	\hline
% 	clk & in & std\_logic \\
% 	reset & in & std\_logic \\
% 	spi\_clk & in & std\_logic \\
% 	spi\_ss & in & std\_logic \\
% 	spi\_mosi & in & std\_logic \\
% 	spi\_data\_available & out & std\_logic \\
% 	spi\_data\_rx & out & std\_logic\_vector(SizeSPIData-1 downto 0) \\
%   	\hline
% \end{tabular}
% \end{table}

% \section{Instruction Decoder}
% De instructiedecoder is er om de door de AVR geleverde data te vertalen naar data (een instructie), waar de draw-module mee over weg kan.
% De decoder leest van SPI-interface een byte (SPIDataRxd), wanneer de SPI-interface aangeeft dat deze klaar staat (SPIDataAvailable).
% Deze byte wordt vervolgens afhankelijk van een interne counter vertaald naar een instructie, kleur of coördinaat.
% Wanneer de decoder met zijn ingebouwde counter bepaalt dat de instructiedata (één of meer bytes) geheel ontvangen is, wordt de bijbehorende actie ondernomen.
% Dit houdt in dat de gewenste draw-module wordt geactiveerd (met het signaal en), of het screen buffer wordt omgewisseld (reg\_id, reg\_value, reg\_set).
% Het actieve screen buffer wordt bijgehouden in een globaal register.
% Dit alles gebeurt uiteraard geheel synchroon en uitgangsdata blijft beschikbaar tot de volgende instructie door middel van flip-flops.
% De in- en uitgangen zijn gespecificeerd in Tabel \ref{tab:spec-decoder}.

% \begin{table}[H]
% \centering
% \caption{Specificaties van de Insctructie Decoder (decoder)}
% \label{tab:spec-decoder}
% \begin{tabular}{c c c}
% 	\hline\hline
%  	Naam & Modus & Type\\
%  	\hline
% 	clk & in & std\_logic \\
% 	reset & in & std\_logic \\	
% 	spi\_data\_rx & out & std\_logic\_vector(SizeSPIData-1 downto 0) \\
% 	spi\_data\_available & in & std\_logic \\
% 	draw\_ready & in & std_logic\\ 	
% 	x &  buffer & std\_logic\_vector(SizeX-1 downto 0) \\
% 	w &  buffer & std\_logic\_vector(SizeX-1 downto 0) \\
% 	y &  buffer & std\_logic\_vector(SizeY-1 downto 0) \\
% 	h &  buffer & std\_logic\_vector(SizeY-1 downto 0) \\
% 	color &  buffer & std\_logic\_vector(SizeColor-1 downto 0) \\
% 	id &  buffer & std\_logic\_vector(SizeSpriteID-1 downto 0) \\
% 	en & buffer & std\_logic\_vector(NumDrawModules-1 downto 0)\\
% 	asb & buffer & std\_logic \\ 
% 	int\_ready & out & std\_logic \\
% 	decoder\_can\_access & in & std\_logic \\
% 	decoder\_claim & out & std\_logic \\
% 	is\_init & out & std\_logic \\
% 	 ramaddr & out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
% 	 ramdata & out & std\_logic\_vector(SizeRAMData-1 downto 0) \\
%   	\hline
% \end{tabular}
% \end{table}

% \section{Draw Module}
% In dit module worden de instructie omgezet naar pixels, rechthoeken en lijnen, die met kleur gevuld kunnen worden.
% Dit module krijgt de informatie binnen van de instructiedecoder, deze geeft aan welke module er gebruikt moet worden met de bijbehorende data (x, y, etc.), ook is er een input die het huidige screen buffer aanduidt (asb).
% De draw module schijft naar het niet-actieve screenbuffer.
% Verder bevat de module de benodigde signals om naar het RAM te schrijven (ramaddr en ramdata) en om te bepalen of er naar het RAM geschreven kan worden op een bepaald moment (draw\_write, draw\_read, draw\_can\_access).

% De in- en uitgangen zijn gespecificeerd in Tabel \ref{tab:spec-draw}.

% \begin{table}[H]
% \centering
% \caption{Specificaties van de Draw Module (draw)}
% \label{tab:spec-draw}
% \begin{tabular}{c c c}
% 	\hline\hline
%  	Naam & Modus & Type\\
%  	\hline	
% 	 clk & in & std\_logic \\
% 	 reset & in & std\_logic \\
% 	id & in & std\_logic\_vector(SizeSpriteID-1 downto 0) \\
% 	 x & in & std\_logic\_vector(SizeX-1 downto 0) \\ 
% 	 w & in & std\_logic\_vector(SizeX-1 downto 0) \\
% 	 y & in & std\_logic\_vector(SizeY-1 downto 0) \\
% 	 h & in & std\_logic\_vector(SizeY-1 downto 0) \\ 
% 	 color & in & std\_logic\_vector(SizeColor-1 downto 0) \\ 
% 	 en & in & std\_logic\_vector(NumDrawModules-1 downto 0) \\ 
% 	 draw\_ready & out & std\_logic \\
% 	 asb & in & std\_logic \\ 
% 	 draw\_write & out & std\_logic \\
% 	 draw\_read & out & std\_logic \\
% 	 draw\_can\_access & in & std\_logic \\
% 	 ramaddr & out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
% 	 ramdata & out & std\_logic\_vector(SizeRAMData-1 downto 0) \\
%   	\hline
% \end{tabular}
% \end{table}

% \subsection {Fill}
% De Fill-module verandert in één instructie het hele beeldscherm naar een gegeven kleur.

% \begin{table}[H]
% \centering
% \caption{Specificaties van de Fill Draw Module}
% \label{tab:spec-fill-draw}
% \begin{tabular}{c c c}
% 	\hline\hline
%  	Naam & Modus & Type\\
%  	\hline	
% 	clk & in & std\_logic \\
% 	reset & in & std\_logic \\
% 	enable& in & std\_logic \\
% 	color & in & std\_logic\_vector(SizeColor-1 downto 0) \\
% 	asb & in & std\_logic \\
% 	done & out & std\_logic \\
% 	ramaddr &out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
% 	ramdata &out & std\_logic\_vector(SizeRAMData-1 downto 0) \\
% 	draw\_write &out & std\_logic \\
% 	draw\_can\_access & in & std\_logic \\
%   	\hline
% \end{tabular}
% \end{table}

% \subsection {Pixel}
% Door deze module worden aparte pixels getekend, hiervoor zijn de x- en y-coördinaten en de kleur van de pixel nodig.

% \begin{table}[H]
% \centering
% \caption{Specificaties van de Pixel Draw Module}
% \label{tab:spec-pixel-draw}
% \begin{tabular}{c c c}
% 	\hline\hline
%  	Naam & Modus & Type\\
%  	\hline	
% 	clk & in & std\_logic \\
% 	reset & in & std\_logic \\
% 	enable& in & std\_logic \\
% 	color & in & std\_logic\_vector(SizeColor-1 downto 0) \\
% 	x & in & std\_logic\_vector(SizeX-1 downto 0) \\
% 	y & in & std\_logic\_vector(SizeY-1 downto 0) \\
% 	asb & in & std\_logic \\
% 	done & out & std\_logic \\
% 	ramaddr &out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
% 	ramdata &out & std\_logic\_vector(SizeRAMData-1 downto 0) \\
% 	draw\_write &out & std\_logic \\
% 	draw\_can\_access & in & std\_logic \\
%   	\hline
% \end{tabular}
% \end{table}

% \subsection {Line}
% Deze module kan lijnen tekenen aan de hand van 2 coördinaten. Met deze coördinaten wordt er gerekend aan de hand van Bresenham's lijn algoritme welke pixels nodig zijn om de 2 coördinaten met een lijn te verbinden.

% \begin{table}[H]
% \centering
% \caption{Specificaties van de Line Draw Module}
% \label{tab:spec-line-draw}
% \begin{tabular}{c c c}
% 	\hline\hline
%  	Naam & Modus & Type\\
%  	\hline	
% 	clk & in & std\_logic \\
% 	reset & in & std\_logic \\
% 	enable& in & std\_logic \\
% 	color & in & std\_logic\_vector(SizeColor-1 downto 0) \\
% 	x0 & in & std\_logic\_vector(SizeX-1 downto 0) \\
% 	y0 & in & std\_logic\_vector(SizeY-1 downto 0) \\
% 	x1 & in & std\_logic\_vector(SizeX-1 downto 0) \\
% 	y1 & in & std\_logic\_vector(SizeY-1 downto 0) \\
% 	asb & in & std\_logic \\
% 	done & out & std\_logic \\
% 	ramaddr &out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
% 	ramdata &out & std\_logic\_vector(SizeRAMData-1 downto 0) \\
% 	draw\_write &out & std\_logic \\
% 	draw\_can\_access & in & std\_logic \\
%   	\hline
% \end{tabular}
% \end{table}

% \subsection {Rectangle}
% In deze module wordt een rechthoek getekend met de x- en y-coördinaten van de eerste pixel links boven en de gegeven afmetingen. De rechthoek kan ook met kleur ingevuld worden. 

% \begin{table}[H]
% \centering
% \caption{Specificaties van de Rectangle Draw Module}
% \label{tab:spec-rect-draw}
% \begin{tabular}{c c c}
% 	\hline\hline
%  	Naam & Modus & Type\\
%  	\hline	
% 	clk & in & std\_logic \\
% 	reset & in & std\_logic \\
% 	enable& in & std\_logic \\
% 	enablef& in & std\_logic \\
% 	color & in & std\_logic\_vector(SizeColor-1 downto 0) \\
% 	x & in & std\_logic\_vector(SizeX-1 downto 0) \\
% 	y & in & std\_logic\_vector(SizeY-1 downto 0) \\
% 	w & in & std\_logic\_vector(SizeX-1 downto 0) \\
% 	h & in & std\_logic\_vector(SizeY-1 downto 0) \\
% 	asb & in & std\_logic \\
% 	done & out & std\_logic \\
% 	ramaddr &out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
% 	ramdata &out & std\_logic\_vector(SizeRAMData-1 downto 0) \\
% 	draw\_write &out & std\_logic \\
% 	draw\_can\_access & in & std\_logic \\
%   	\hline
% \end{tabular}
% \end{table}

% \subsection {Sprite}
% In deze module wordt een sprite uitgelezen/ingeschreven vanuit het RAM en getekend op het scherm aan de hand van de x- en y- coördinaten van de eerste pixel links boven en de lengte, deze lengte geeft aan hoeveel adressen lang de sprite is.
% \begin{table}[H]
% \centering
% \caption{Specificaties van de Sprite Draw Module}
% \label{tab:spec-sprite-draw}
% \begin{tabular}{c c c}
% 	\hline\hline
%  	Naam & Modus & Type\\
%  	\hline	
% 	clk & in & std\_logic \\
% 	reset & in & std\_logic \\
% 	enable& in & std\_logic \\
% 	id & in & std\_logic\_vector(SizeSpriteID-1 downto 0) \\
% 	color & in & std\_logic\_vector(SizeColor-1 downto 0) \\
% 	x & in & std\_logic\_vector(SizeX-1 downto 0) \\
% 	y & in & std\_logic\_vector(SizeY-1 downto 0) \\
% 	w & in & std\_logic\_vector(SizeX-1 downto 0) \\
% 	l & in & std\_logic\_vector(SizeSpriteCounter-1 downto 0) \\
% 	asb & in & std\_logic \\
% 	done & out & std\_logic \\
% 	ramaddr &out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
% 	ramdata &out & std\_logic\_vector(SizeRAMData-1 downto 0) \\
% 	draw\_write &out & std\_logic \\
% 	draw\_read &out & std\_logic \\
% 	draw\_can\_access & in & std\_logic \\
%   	\hline
% \end{tabular}
% \end{table}

% \section{RAM Controller}
% Omdat we een externe RAM gebruiken voor onze screenbuffers is het nodig om hiervoor communicatie op te stellen, zodat er in het juiste gedeelte van de RAM geschreven en gelezen wordt en dat dit niet tegelijkertijd gebeurd, omdat het RAM dat niet aankan. We hebben voor een externe RAM gekozen omdat er geen RAM geheugen groot genoeg gemaakt kon worden met de benodigde transistoren om bijvoorbeeld de screenbuffers te renderen. De RAM controller stuurt naar het draw-module een signaal write als het mag gaan schrijven in het RAM geheugen, de RAM controller krijgt dan de kleur en het adress binnen van het draw-module. Als de VGA controller mag gaan lezen krijgt het een signaal read binnen van de RAM controller dan zal er weer data naar de VGA controller verstuurd worden, kleur en adres.

% \begin{table}[H]
% \centering
% \caption{Specificaties van de RAM Controller (ramcontroller)}
% \label{tab:spec-ramcontroller}
% \begin{tabular}{c c c}
% 	\hline\hline
%  	Naam & Modus & Type\\
%  	\hline	
% 	write\_enable & out & std\_logic\\
% 	vga\_claim & in & std\_logic\\
% 	decoder\_claim & in & std\_logic\\
% 	is\_init & in & std\_logic\\
% 	decoder\_write & in & std\_logic\\
% 	draw\_write & in & std\_logic\\
% 	draw\_read & in & std\_logic\\
% 	vga\_read & in & std\_logic\\
% 	draw\_can\_access & out & std\_logic\\
% 	decoder\_can\_access & out & std\_logic\\
% 	vga\_can\_access & out & std\_logic\\
%   	\hline
% \end{tabular}
% \end{table}

% \section{VGA Controller}
% De VGA-controller leest het actieve screen buffer uit het RAM en zet de gelezen data om in beelduitvoer.

% \begin{table}[H]
% \centering
% \caption{Specificaties van de VGA Controller (vgacontroller)}
% \label{tab:spec-vgacontroller}
% \begin{tabular}{c c c}
% 	\hline\hline
%  	Naam & Modus & Type\\
%  	\hline	
% 	clk & in & std\_logic \\ 
% 	reset\_n & in & std\_logic \\ 
% 	vgahsync & out & std\_logic \\ 
% 	vgavsync & out & std\_logic \\ 
% 	vgacolor & out & std\_logic\_vector(SizeColor-1 downto 0) \\
% 	vga\_claim & out & std\_logic \\ 
% 	ramaddr & out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
% 	ramdata & in & std\_logic\_vector(SizeRAMData-1 downto 0) \\ 
% 	vga\_read & out & std\_logic \\
% 	vga\_can\_access & in & std\_logic \\
% 	asb & in & std\_logic \\
%   	\hline
% \end{tabular}
% \end{table}

\end{document}
