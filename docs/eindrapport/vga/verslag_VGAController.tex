\documentclass{scrartcl}  % scrartcl of scrreprt
\usepackage{SIunits}
\input{../library/preamble}  
\input{../library/style}
\addbibresource{../library/bibliography.bib}

\author{ Jorden {Kerkhof}  }
\title{EPO3: Eindrapport}
\subtitle{VGA\_controller}
\date {\today}


\begin{document}
\pagenumbering{roman}
\maketitle
\vspace{80 mm}

\newpage
\setlength{\cftbeforetoctitleskip}{-3em}
\tableofcontents
\newpage

\section{Inleiding}
De VGA-controller is een belangrijk component in ons systeem. Deze zorgt er namelijk voor dat alles wat berekend wordt in de module daadwerkelijk zichtbaar wordt gemaakt. De VGA-controller legt de verbinding tussen de rest van ons systeem en een scherm, hierdoor is fysiek te zien wat er gebeurt in het systeem. 

\section{Specificaties}

De specificaties van de VGA-controller zijn uitgedrukt in de in- en uitgangen van dit component. Hieronder een overzichtelijk tabel daarvan. Bij de vectoren is de grootte gegeven in parameters. Deze parameters zijn terug te vinden in de beschrijving van het package file, welke eerder is besproken in dit verslag.

\begin{table}[H]
\centering
\caption{Specificaties van de VGA Controller }
\label{tab:spec-vgacontroller}
\begin{tabular}{c c c}
	\hline\hline
 	Naam & Modus & Type\\
 	\hline	
	clk & in & std\_logic \\ 
	reset\_n & in & std\_logic \\ 
	vgahsync & out & std\_logic \\ 
	vgavsync & out & std\_logic \\ 
	vgacolor & out & std\_logic\_vector(SizeColor-1 downto 0) \\
	vga\_claim & out & std\_logic \\ 
	ramaddr & out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
	ramdata & in & std\_logic\_vector(SizeRAMData-1 downto 0) \\ 
	vga\_read & out & std\_logic \\
	vga\_can\_access & in & std\_logic \\
	asb & in & std\_logic \\
  	\hline\hline
\end{tabular}
\end{table}


\section{VHDL-Beschrijving}
\subsection{Entity}
Aan het begin van de entity worden eerst een aantal constanten gecreeerd. Deze zijn afgesteld op de grootte van ons resolutie en hoe snel we het scherm willen verversen. In het ontwerp is al grotendeels besproken welke signalen binnenkomen in de VGA-controller. De ingangen zijn vrij standaard. De ingangen zijn clk(clock), reset\_n (negative reset), ramdata, vga\_can\_access en asb( active screen buffer). . De uitgangen zijn vgahsync, vgavsync, vgacolor, vga\_claim, ramaddr en vga\_read. Vgahync en vgavsync zijn hier de horizontalen en verticale synchronisatie pulsen. Vgacolor is een vector die informatie bevat over de kleur. Ramaddr is het adres van de pixel waar het scherm op dit moment is. Vga\_claim is een signaal dat aangeeft dat de vga-controller op dit moment toegang heeft tot de RAM. VGA\_read geeft aan dat de VGA-controller de RAM gegevens uitleest.

\subsection{Behaviour}
Als eerste worden er een aantal belangrijke constanten en signalen gedeclareerd in de behaviour. De periode van de horizontale en de verticale synchronisatie pulsen bepalen hoe lang er doorgeteld moet worden totdat je het hele scherm bent afgegaan. We hebben deze zo ingesteld dat ze iets groter zijn dan onze resolutie daadwerkelijk is. Dit om ervoor te zorgen dat als de vga-controller aan het tekenen is buiten het scherm dat de waarden even weer goed kunnen worden ingelezen. Omdat we een negatieve reset hebben, gaat de code werken als de reset hoog is. Vervolgens begint de vga-controller te synchroniseren. Hij begint buiten het scherm en zorgt ervoor dat de juiste data aan de ingangen staat. Vervolgens begint hij van links naar recht, van boven naar beneden het scherm in te vullen. Elk moment dat hij bij een bepaalde pixel is geeft hij dit adres door aan de RAM-controller. Deze leest uit de RAM welke kleur deze pixel moet hebben en stuurt dit rechtstreeks door naar de vga-controller. Deze stuurt dat gelijk door naar de uitgang zodat de correcte kleur op het goede moment en het juiste tijdstip wordt afgebeeld. 


\section{Testplan}
Om te testen of de vhdl-code werkte hebben we een testbench geschreven. Hier hebben we alle mogelijke situaties gesimuleerd. De testbench is te vinden in de bijlage. Hieronder een overzicht van de resultaten van de simulatie.
\begin{figure}[H]
\centering
		\setlength\figureheight{0.6\textwidth}
		\setlength\figurewidth{0.9\textwidth}
		\input{images/simmod.png}
		\caption{Het resultaat van de simulatie in Modelsim.}
		\label{fig:sim}
\end{figure}
\section{Synthese}
Voor de synthese hebben we het programma GoWithTheFlow gebruikt. Hier kwam een gesynthetiseerde versie uit, ook deze hebben we gesimuleerd.
\section{Switch-level resultaten}
\section{Extracted}
\section{Conclusie}
Uit meerdere simulaties blijkt dat de code werkt. De resultaten van de simulatie komen overeen met de gewenste resultaten. Dit houdt in dat de code naar behoren werkt en goed te implementeren is. De code zal waarschijnlijk geen problemen geven als deze ge√Ømplementeerd wordt.
\section{Discussie}
\end{document}
%
%\section{Theorie}
%
%
%
%\section{Simulaties}
%
%
%
%\section{Resultaten}
%
%\begin{figure}[H]
%\centering
%                \setlength\figureheight{0.6\textwidth} 
%                \setlength\figurewidth{0.9\textwidth}
%                \input{images/t-v_meet.tikz}
%                \caption{Het resultaat van de simulatie met drie inverters.}
%                \label{fig:meetdrie}
%\end{figure}
%En het resultaat van de simulatie met vijf inverters is zoals in figuur \ref{fig:meetvijf}.
%
%Aan alleen deze plots hadden we niet zoveel om de vraag {\it 'Wat is het kleinst aantal inverters waarbij een betrouwbare oscillatie optreed?'} te beantwoorden. Om deze vraag wel te kunnen beantwoorden hebben we nog een extra plot gemaakt, zie figuur \ref{fig:tplhtphl5}. Uit deze plot hebben we de $T_{pHL}$ en $T_{pLH}$ waarde van onze simulatie afgelezen. De $T_{pHL}$ waarde vonden we door bij de eerste opgaande flank van de blauwe golf op ongeveer 50\% van de golf een horizontale lijn (helaas konden we die niet weergeven in de figuur) te tekenen tot er een raakpunt is met de rode lijn. Door vervolgens de resultaten van elkaar af te halen vonden we een $T_{pHL}$ van 0.107\nano\second\ . Om nu vervolgens de waarde van $T_{pLH}$ te vinden hebben we wederom een horizontale lijn getrokken met het beginpunt op 50\% van de neergaande flank van de eerste blauwe golf en het eindpunt op de opgaande flank van de tweede rode golf. Dit gaf ons een waarde van 0.21\nano\second\ voor $T_{pLH}$.
%
%\begin{figure}[H]
%\centering
%                \setlength\figureheight{0.6\textwidth} 
%                \setlength\figurewidth{0.9\textwidth}
%                \input{images/tplh-tphl5.tikz}
%                \caption{Figuur gebruikt om de $T_{pLH}$ en $T_{pHL}$ te berekenen.}
%                \label{fig:tplhtphl5}
%\end{figure}
%Aan de hand van deze waarde kunnen we de oscillatiefrequentie berekenen met de volgende formule: 
%\begin{equation}
%Frequentie = 1/(N*(T_{pHL}+T_{pLH}))
%\end{equation}
%
% 
%\\en voor vijf inverters:
%
%
%\section{Conclusie}
%
%\begin{itemize}
%	\item Hoe meer inverters je gebruikt, hoe groter de delay, hoe kleiner de oscillatiefrequentie.
%	\item Hoe meer inverters we gebruiken, hoe kleiner het verschil wordt tussen onze gemeten waarde en de waarde verkregen uit de sanity-check.
%\end{itemize}
%Hierdoor kunnen wij concluderen dat het minst aantal inverters wat nodig is voor een betrouwbare oscillatie zal liggen bij vijf  
%
%
%\section{Discussie}
%
%
%\newpage
%\section{Bibliografie}
%\printbibliography
