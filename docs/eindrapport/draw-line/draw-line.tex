\documentclass{scrartcl} % scrartcl of scrreprt
\input{../../library/preamble.tex}
\input{../../library/style.tex}
\addbibresource{../../library/bibliography.bib}

\author{Robin Hes}
\title{EPO3: Eindrapport - Draw-line}

\begin{document}
\section{Draw-line}
\label{sec:draw-line}
De naam zegt het al: de draw-line module heeft als taak het tekenen van lijnen in het screen buffer. Voor dit doeleinde wordt gebruik gemaakt van het lijnalgoritme van Bresenham. Specifiek een voor hardware geöptimaliseerde en gesimplificeerde versie van dat algoritme. \cite{line-alg} Dit algoritme tekent in een loop een rij pixels van een punt naar een ander punt, waarvan de coördinaten per iteratie in de x-richting, y-richting, of beide richtingen verschuiven. De coördinaten van de nieuwe pixel worden berekend aan de hand van de afwijking tussen het verschil tussen de begin- en eindcoördinaat (dx en dy) en de laatst getekende pixel.

%Specs
\subsection{Specificaties}
Draw\_line is gespecificeerd als een module die, wanneer hij ingeschakeld is (en = `1') en toegang heeft tot het RAM (draw\_can\_access = `1') een lijn van de gewenste kleur (color), van (x0 en y0) en naar (x1 en y1) de gewenste coördinaten naar het VRAM schrijft. Hij doet dit in het niet-actieve screenbuffer (not asb), zodat de lijn na de volgende schermbufferwisseling door de VGA-controller op het scherm getekend wordt. De aansluitingen van de module zijn te vinden in figuur \ref{fig:decoder-schema}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.75\textwidth]{resource/draw_line.png}
	\caption{Een blokschema van draw\_line, met de namen van de gebruikte in- en uitgangen en tussen haakjes het aantal bits}
	\label{fig:decoder-schema}
\end{figure}
% \begin{table}[H]
% \centering
% \caption{Specificaties van de Line Draw Module}
% \label{tab:spec-line-draw}
% 	\begin{tabular}{c c c}
% 		\hline\hline
% 	 	Naam & Modus & Type\\
% 	 	\hline	
% 		clk & in & std\_logic \\
% 		reset & in & std\_logic \\
% 		enable& in & std\_logic \\
% 		color & in & std\_logic\_vector(SizeColor-1 downto 0) \\
% 		x0 & in & std\_logic\_vector(SizeX-1 downto 0) \\
% 		y0 & in & std\_logic\_vector(SizeY-1 downto 0) \\
% 		x1 & in & std\_logic\_vector(SizeX-1 downto 0) \\
% 		y1 & in & std\_logic\_vector(SizeY-1 downto 0) \\
% 		asb & in & std\_logic \\
% 		done & out & std\_logic \\
% 		ramaddr &out & std\_logic\_vector(SizeRAMAddr-1 downto 0) \\
% 		ramdata &out & std\_logic\_vector(SizeRAMData-1 downto 0) \\
% 		draw\_write &out & std\_logic \\
% 		draw\_can\_access & in & std\_logic \\
% 	  	\hline
% 	\end{tabular}
% \end{table}

%VHDL
\subsection{VHDL}
De implementatie van de module is een letterlijke implementatie van het eerdergenoemde algoritme. De pseudocode voor dit algoritme is voor de volledigheid opgenomen in bijlage \ref{appsec:pseudocode-bresenham-line}. Het enige probleem bij het omzetten van pseudocode naar een VHDL FSM was het feit dat er geen loop gebruikt kon worden om te itereren, omdat er niet meerdere keren naar het VRAM geschreven kan worden per klokslag.
\\
In plaats daarvan is gekozen om in het combinatorische process van de module één iteratie te verwerken (en dus één pixel naar het screen buffer te schrijven) en de state zo aan te passen dat de volgende executie van het process de volgende iteratie uitvoert en zo verder.
\\
De module begint op x0 en y0 en schuift iedere process-executie op naar een nieuwe pixel, de locatie van deze pixel wordt intern bijgehouden met de signalen cx en cy. De nieuwe pixel kan verschoven zijn in de x- of y-richting of beide richtingen. Dit is afhankelijk van de ``fout'', die in Bresenham's algoritme berekend wordt, deze fout is afhankelijk van het verschil tussen het start- en eindpunt van de lijn: dx en dy. Naast het verplaatsen van de huidige pixel wordt deze ook bij iedere iteratie weggeschreven naar het VRAM. Dit betekent dat er een kleur in het niet-actieve gedeelte van het VRAM wordt geschreven op het juiste adres. Dit adres (ramaddr) is dan een combinatie van asb, cx en cy, waar de te schrijven data (ramdata) simpelweg bestaat uit de gegeven kleur (color).

%Testplan VHDL
\subsection{Testplan}
De draw-line module is getest met een testbench waarin één lijn wordt getekend. In de waveform in ModelSim is dan eenvoudig te zien of de coördinaten van de getekende pixels inderdaad op elkaar volgen en dus mogelijkerwijs een lijn vormen. Wanneer dit zo is kan de module in combinatie met de overige delen van de GPU gesimuleerd worden. Het resultaat hiervan kan gecontroleerd worden met de SRAMDebugTool, waarin dan daadwerkelijk een lijn waar zou zijn te nemen. Als laatst wordt de lijn op de FPGA geïmplementeerd en kan worden gecontroleerd of op het beeldscherm inderdaad een lijn verschijnt.

%Synthese
\subsection{Synthese}


%Switchlevel test
\subsection{Switchlevel}


%Extracted test
\subsection{Extracted}

%Conclusie
\subsection{Conclusie}

\end{document}
